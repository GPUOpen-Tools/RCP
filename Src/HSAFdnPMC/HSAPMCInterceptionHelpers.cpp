//==============================================================================
// Copyright (c) 2015 Advanced Micro Devices, Inc. All rights reserved.
/// \author AMD Developer Tools Team
/// \file
/// \brief  This file contains functions called by various intercepted APIs
//==============================================================================

#include "Logger.h"

#include "HSAToolsRTModule.h"
#include "HSARTModuleLoader.h"
#include "FinalizerInfoManager.h"
#include "HSAGPAProfiler.h"
#include "HSAPMCInterceptionHelpers.h"
#include "AutoGenerated/HSAPMCInterception.h"
#include <amd_hsa_tools_interfaces.h>

void HSA_PMC_PreDispatchCallback(const hsa_dispatch_callback_t* pRTParam, void* pUserArgs)
{
    SP_UNREFERENCED_PARAMETER(pUserArgs);
    // TODO: assert that pRTParam is not null and pRTParam->pre_dispatch is true

    HSAToolsRTModule* pToolsRTModule = HSARTModuleLoader<HSAToolsRTModule>::Instance()->GetHSARTModule();

    if (HSAGPAProfiler::Instance()->HasKernelMaxBeenReached())
    {
        // reached max number of dispatches -- uninstall pre/post dispatch callback so we don't profile any additional kernels
        if (pToolsRTModule->IsModuleLoaded())
        {
            pToolsRTModule->ext_tools_set_callback_functions(const_cast<hsa_queue_t*>(pRTParam->queue), NULL, NULL);
        }
    }
    else if (HSAGPAProfiler::Instance()->IsProfilingEnabled())
    {
        bool ret = HSAGPAProfiler::Instance()->Begin(pRTParam->agent, pRTParam->queue, pRTParam->aql_packet, pRTParam->aql_translation_handle);

        if (!ret)
        {
            return;
        }
    }
}

void HSA_PMC_PostDispatchCallback(const hsa_dispatch_callback_t* pRTParam, void* pUserArgs)
{
    SP_UNREFERENCED_PARAMETER(pUserArgs);

    // TODO: potential race condition where profiling enabled state changes in between pre and post dispatch callbacks
    if (HSAGPAProfiler::Instance()->IsProfilingEnabled())
    {
        // TODO: assert that pRTParam is not null and pRTParam->pre_dispatch is false
        bool ret = HSAGPAProfiler::Instance()->End(pRTParam->agent, pRTParam->queue, pRTParam->aql_translation_handle, pRTParam->signal);

        if (!ret)
        {
            return;
        }
    }
}

void HSA_PMC_hsa_agent_get_info_PostCallHelper(hsa_status_t retVal, hsa_agent_t agent, hsa_agent_info_t attribute, void* value)
{
    // spoof the return value of the min queue size query for the user app to be at least 128
    if (HSA_STATUS_SUCCESS == retVal && NULL != value && HSA_AGENT_INFO_QUEUE_MIN_SIZE == attribute)
    {
        // first check the return value of the min queue size from the runtime
        uint32_t* minQueueSize = static_cast<uint32_t*>(value);

        if (MIN_QUEUE_SIZE_FOR_SOFTCP > *minQueueSize)
        {
            // the min queue size is less than 128 -- let check to see if the max queue size is at least 128
            uint32_t maxQueueSize = 0;
            hsa_status_t status = g_pRealCoreFunctions->hsa_agent_get_info_fn(agent, HSA_AGENT_INFO_QUEUE_MAX_SIZE, &maxQueueSize);

            if (HSA_STATUS_SUCCESS == status && MIN_QUEUE_SIZE_FOR_SOFTCP <= maxQueueSize)
            {
                // the max queue size is at least 128, so return 128 to the user app
                *minQueueSize = MIN_QUEUE_SIZE_FOR_SOFTCP;
            }
        }
    }
}

void HSA_PMC_hsa_queue_create_PostCallHelper(hsa_status_t retVal, hsa_agent_t agent, uint32_t size, hsa_queue_type32_t type, void(*callback)(hsa_status_t status, hsa_queue_t* source,
                                             void* data), void* data, uint32_t private_segment_size, uint32_t group_segment_size, hsa_queue_t** queue)
{
    SP_UNREFERENCED_PARAMETER(agent);
    SP_UNREFERENCED_PARAMETER(size);
    SP_UNREFERENCED_PARAMETER(type);
    SP_UNREFERENCED_PARAMETER(callback);
    SP_UNREFERENCED_PARAMETER(data);
    SP_UNREFERENCED_PARAMETER(private_segment_size);
    SP_UNREFERENCED_PARAMETER(group_segment_size);

    if (HSA_STATUS_SUCCESS == retVal && NULL != queue)
    {
        HSAToolsRTModule* pToolsRTModule = HSARTModuleLoader<HSAToolsRTModule>::Instance()->GetHSARTModule();

        if (pToolsRTModule->IsModuleLoaded())
        {
            hsa_status_t status = pToolsRTModule->ext_tools_set_callback_functions(*queue, HSA_PMC_PreDispatchCallback, HSA_PMC_PostDispatchCallback);

            if (HSA_STATUS_SUCCESS != status)
            {
                Log(logERROR, "Error setting pre/post dispatch callback functions\n");
            }
        }
    }
}

void HSA_PMC_hsa_queue_destroy_PreCallHelper(hsa_queue_t* queue)
{
    if (NULL != queue)
    {
        HSAGPAProfiler::Instance()->WaitForCompletedSession(queue->id);
    }
}

void HSA_PMC_hsa_executable_get_symbol_PostCallHelper(hsa_status_t retVal, hsa_executable_t executable, const char* module_name, const char* symbol_name, hsa_agent_t agent, int32_t call_convention, hsa_executable_symbol_t* symbol)
{
    SP_UNREFERENCED_PARAMETER(executable);
    SP_UNREFERENCED_PARAMETER(module_name);
    SP_UNREFERENCED_PARAMETER(agent);
    SP_UNREFERENCED_PARAMETER(call_convention);

    if (HSA_STATUS_SUCCESS == retVal && NULL != symbol)
    {
        if (NULL != symbol_name)
        {
            Log(logMESSAGE, "HSA_PMC_hsa_executable_get_symbol: Adding symbol handle/symbol name pair to FinalizerInfoManager\n");
            Log(logMESSAGE, "  SymHandle: %llu, SymName: %s \n", symbol->handle, symbol_name);
            FinalizerInfoManager::Instance()->m_symbolHandleToNameMap[symbol->handle] = std::string(symbol_name);

            uint64_t kernelObject;

            if (g_pRealCoreFunctions->hsa_executable_symbol_get_info_fn(*symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT, &kernelObject) == HSA_STATUS_SUCCESS)
            {
                Log(logMESSAGE, "HSA_PMC_hsa_executable_get_symbol: Adding code handle/symbol handle pair to FinalizerInfoManager\n");
                Log(logMESSAGE, "  CodeHandle: %llu, SymHandle: %llu\n", kernelObject, symbol->handle);
                FinalizerInfoManager::Instance()->m_codeHandleToSymbolHandleMap[kernelObject] = symbol->handle;
            }
        }
    }
}

void HSA_PMC_hsa_executable_get_symbol_by_name_PostCallHelper(hsa_status_t retVal, hsa_executable_t executable, const char* symbol_name, const hsa_agent_t* agent, hsa_executable_symbol_t* symbol)
{
    SP_UNREFERENCED_PARAMETER(executable);
    SP_UNREFERENCED_PARAMETER(agent);

    if (HSA_STATUS_SUCCESS == retVal && NULL != symbol)
    {
        if (NULL != symbol_name)
        {
            Log(logMESSAGE, "HSA_PMC_hsa_executable_get_symbol: Adding symbol handle/symbol name pair to FinalizerInfoManager\n");
            Log(logMESSAGE, "  SymHandle: %llu, SymName: %s \n", symbol->handle, symbol_name);
            FinalizerInfoManager::Instance()->m_symbolHandleToNameMap[symbol->handle] = std::string(symbol_name);

            uint64_t kernelObject;

            if (g_pRealCoreFunctions->hsa_executable_symbol_get_info_fn(*symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT, &kernelObject) == HSA_STATUS_SUCCESS)
            {
                Log(logMESSAGE, "HSA_PMC_hsa_executable_get_symbol: Adding code handle/symbol handle pair to FinalizerInfoManager\n");
                Log(logMESSAGE, "  CodeHandle: %llu, SymHandle: %llu\n", kernelObject, symbol->handle);
                FinalizerInfoManager::Instance()->m_codeHandleToSymbolHandleMap[kernelObject] = symbol->handle;
            }
        }
    }
}

void HSA_PMC_hsa_executable_symbol_get_info_PostCallHelper(hsa_status_t retVal, hsa_executable_symbol_t executable_symbol, hsa_executable_symbol_info_t attribute, void* value)
{
    SP_UNREFERENCED_PARAMETER(attribute);

    if (HSA_STATUS_SUCCESS == retVal && nullptr != value)
    {
        uint32_t symbolNameLength = 0;

        if (g_pRealCoreFunctions->hsa_executable_symbol_get_info_fn(executable_symbol, HSA_EXECUTABLE_SYMBOL_INFO_NAME_LENGTH, &symbolNameLength) == HSA_STATUS_SUCCESS)
        {
            if (symbolNameLength > 0)
            {
                char* tempSymbolName = new(std::nothrow) char[symbolNameLength + 1];

                if (nullptr != tempSymbolName)
                {
                    memcpy(tempSymbolName, value, symbolNameLength);
                    tempSymbolName[symbolNameLength] = '\0';
                    Log(logMESSAGE, "HSA_API_Trace_hsa_executable_get_symbol: Adding symbol handle/symbol name pair to FinalizerInfoManager\n");
                    Log(logMESSAGE, "  SymHandle: %llu, SymName: %s \n", executable_symbol.handle, tempSymbolName);
                    FinalizerInfoManager::Instance()->m_symbolHandleToNameMap[executable_symbol.handle] = std::string(tempSymbolName);
                    delete[] tempSymbolName;

                    uint64_t kernelObject;

                    if (g_pRealCoreFunctions->hsa_executable_symbol_get_info_fn(executable_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT, &kernelObject) == HSA_STATUS_SUCCESS)
                    {
                        Log(logMESSAGE, "HSA_API_Trace_hsa_executable_get_symbol: Adding code handle/symbol handle pair to FinalizerInfoManager\n");
                        Log(logMESSAGE, "  CodeHandle: %llu, SymHandle: %llu\n", kernelObject, executable_symbol.handle);
                        FinalizerInfoManager::Instance()->m_codeHandleToSymbolHandleMap[kernelObject] = executable_symbol.handle;
                    }
                }
            }
        }
    }
}
